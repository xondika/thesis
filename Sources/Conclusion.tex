\chapter{Conclusion}

The aim of this thesis was to implement an algorithm for planning the trajectory of robotic manipulators with a high degree of freedom. To solve the problem, we decomposed it into two parts: planning a path with respect to the \textit{end effector}, and extending an inverse kinematics algorithm to compute positions for the manipulator along the selected path.

We've added two extensions to the state of the art algorithm for inverse kinematics, FABRIK. The first dealt with adapting the algorithm to joints with a limited range of motion, and the latter dealt with local collision avoidance for each joint.

In order to plan a path for the end effector, we build a visibility graph of points between obstacles, and use Djikstra's algorithm to find the shortest path. Then, we try to follow this path with the manipulator, using FABRIK to check whether the path is feasible. If following the path fails, vertices near the path are given an increased cost, and a different path is evaluated as shortest instead. The process is repeated multiple times in order to explore different ways to get around obstacles. Either a viable path is found, or the target is deemed unreachable.

We've shown that the algorithm performs smooth motion, but the chosen trajectory is generally not optimal. It serves as a heuristic with a high success rate, which can fail in specific environments.

During experimental evaluation, we've shown that the algorithm is fast for manipulators with 12 degrees of freedom, more than twice the usual amount. To the best of our knowledge, this is revolutionary: traditional approaches are adapted to 6-DoF manipulators and scale exponentially with each additional joint. Up to 15 DoF and 25 obstacles, we obtain viable solutions within a few seconds at most, which defeats any previously published results.

Further improvements are due: we can reduce the overall time by shutting down unsuccessful paths earlier, optimising some of the constants in the implementation, and more. With a more polished implementation, the algorithm can become even faster and more successful. We also want to extend the algorithm to a physical version of our robots. This means extending FABRIK so that it only makes movements that are feasible when gravity is involved, as well as dealing with communication between the modules and potential failure. On the other hand, the distributed system of multiple modules can be used very effectively within the algorithm: upon finding multiple possible paths, we can compute whether they're feasible in parallel, speeding up the main bottleneck of the current version. If multiple paths are found this way, we can choose the one that minimizes the amount of motion.

Overall, it's safe to say we've achieved our goal with great success.
