%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


In a world of automation, we would like to tell our robots a task such
as \enquote{Hand me a coffee.} and expect them to do it without giving
specific instructions of \textit{how} to do it.

This seemingly basic task contains many interesting subproblems, including but not limited to
the high level design of the robot, hardware design and programming, image or speech recognition, and human computer interaction.
For us, the critical part will be performing the task itself; in this case, computing and realising the movement necessary to grab a cup and deliver it to the target location.

A natural way for us to approach the problem is to create a humanoid robot, or simply a robotic arm on a fixed base. Even if we limit ourselves to the latter, the idea is quite fascinating; outside of making coffee for computer scientists, it can assist engineers or surgeons in their work.

This thesis aims to create a general algorithm for controlling robotic arms.
Our assumption is that we have a robotic arm that is fixed in place and has a high number of joints.
Naturally, the joints on the arm will have limited range, as many real arms do.
The task we are aiming to accomplish is to plan movement of the arm from one place to another, while avoiding collisions with other objects in the workspace of the arm.
The performed movement should be reasonably efficient, and the computation needs to be fast.

The presented methods will not be limited to a specific setup, but the results will be demostrated on top of the RoFI platform\cite{rofiPlatform}.

As computer scientists, we can already sense that we are tackling a rather complex problem, which is yet to be solved by the robotic community. Obstacles and joint constraints generally make the problem of motion planning\footnote{The general problem of computing the motion of a robot. It encompasses robotic arms as well as self driving cars and walking robots.} hard to perform, and the task of finding a good solution often goes directly against the task of finding a solution quickly.
There are many existing attempts to create an algorithm for motion planning of robotic arms,
some of which have been successfully used in practice to perform a specific task. Each method has specific advantages and disadvantages, which will be discussed in further chapters of this thesis.

What mostly sets our goals apart from previous research is the assumption that we have a high number of joints. This fact, at its core, makes traditional methods for related problems computationally infeasible.
Being unable to use a single existing method will lead us to decomposing the problem into smaller parts and combining various algorithms from different areas. By the end, we hope to build a satisfiable solution, starting with each component from the ground up.

Outside of robotics, having a general algorithm with this specification is interesting for computer graphics, in particular for generating character movement in videogames.
With an algorithm that can compute the motion of a constrained limb with a high number of joints at our disposal, we can design complex kinematic models and animate movement of the respective characters in complex environments.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Outline of the work}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This thesis will try to lead the reader through the process of designing an algorithm for the motion planning of robotic arms. We will start with a more formal definition of the problem, preliminary knowledge, and introduction of the platform our solution will be presented on.

As we try to incrementally design an algorithm, the discussion of state of the art methods, some mathematical theory, and main ideas behind the implementation will be tied together to create the core of this thesis. Each idea will be accompanied by the intuition behind it, as well as a visual representation. Apart from the ideas that will build our final solution, we will explore methods that were not successful, and discuss the limits of different approaches.

Finally, the solution will be tested and evaluated. We will showcase the behavior of the algorithm in various environments, and present a possible application for it. We will run benchmarks to evaluate the efficiency and success rate of the algorithm. At the end, takeaways from the design process and further improvements will be discussed.
